// Generated by CoffeeScript 1.3.3

/*
License agreements:
1) Feel free to modify the code.
2) Feel free to credit the author.
3) Keep being awesome.

Keypress
A keyboard input capturing utility in which any key can be a modifier key.
Requires jQuery
Author: David Mauro

Options available and defaults:
    keys            : []        - An array of the keys pressed together to activate combo
    count           : 0         - The number of times a counting combo has been pressed. Reset on release.
    allow_default   : false     - Allow the default key event to happen in addition to the combo.
    is_ordered      : false     - Unless this is set to true, the keys can be pressed down in any order
    is_counting     : false     - Makes this a counting combo (see documentation)
    is_sequence     : false     - Rather than a key combo, this is an ordered key sequence
    prevent_repeat  : false     - Prevent the combo from repeating when keydown is held.
    on_keyup        : null      - A function that is called when the combo is released
    on_keydown      : null      - A function that is called when the combo is pressed.
    on_release      : null      - A function that is called for counting combos when all keys are released.
*/


(function() {
  var key, _, _active_combos, _add_key_to_sequence, _add_to_active_combos, _allow_key_repeat, _bug_catcher, _cmd_bug_check, _combo_defaults, _compare_arrays, _convert_key_to_readable, _decide_meta_key, _event_classname, _fire, _get_active_combo, _get_potential_combo, _get_sequence, _key_down, _key_up, _keycode_dictionary, _keys_down, _keys_remain, _log_error, _match_combo_arrays, _metakey, _modifier_keys, _prevent_capture, _prevent_default, _receive_input, _registered_combos, _remove_from_active_combos, _sequence, _sequence_timer, _valid_keys, _validate_combo,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  _registered_combos = [];

  _sequence = [];

  _sequence_timer = null;

  _keys_down = [];

  _active_combos = [];

  _prevent_capture = false;

  _event_classname = "keypress_events";

  _metakey = "ctrl";

  _modifier_keys = ["meta", "alt", "option", "ctrl", "shift", "cmd"];

  _valid_keys = [];

  _combo_defaults = {
    keys: [],
    count: 0,
    test: "hello"
  };

  _log_error = function(msg) {
    return console.log(msg);
  };

  _compare_arrays = function(a1, a2) {
    var item, _i, _j, _len, _len1;
    if (a1.length !== a2.length) {
      return false;
    }
    for (_i = 0, _len = a1.length; _i < _len; _i++) {
      item = a1[_i];
      if (__indexOf.call(a2, item) >= 0) {
        continue;
      }
      return false;
    }
    for (_j = 0, _len1 = a2.length; _j < _len1; _j++) {
      item = a2[_j];
      if (__indexOf.call(a1, item) >= 0) {
        continue;
      }
      return false;
    }
    return true;
  };

  _prevent_default = function(e) {
    return e.preventDefault();
  };

  _allow_key_repeat = function(combo) {
    if (combo.prevent_repeat) {
      return false;
    }
    if (typeof combo.on_keydown === "function") {
      return true;
    }
  };

  _keys_remain = function(combo) {
    var key, keys_remain, _i, _len, _ref;
    _ref = combo.keys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (__indexOf.call(_keys_down, key) >= 0) {
        keys_remain = true;
        break;
      }
    }
    return keys_remain;
  };

  _fire = function(event, combo) {
    if (typeof combo["on_" + event] === "function") {
      combo["on_" + event]();
    }
    if (event === "keyup") {
      return combo.keyup_fired = true;
    }
  };

  _match_combo_arrays = function(potential_match, source_combo_array, allow_partial_match) {
    var source_combo, _i, _len;
    if (allow_partial_match == null) {
      allow_partial_match = false;
    }
    for (_i = 0, _len = source_combo_array.length; _i < _len; _i++) {
      source_combo = source_combo_array[_i];
      if (source_combo_array.is_sequence) {
        continue;
      }
      if (source_combo.is_ordered) {
        console.log("potential_match", potential_match, potential_match.join, source_combo, source_combo.keys);
        if (potential_match.join("") === source_combo.keys.join("")) {
          return source_combo;
        }
        if (allow_partial_match && potential_match.join("") === source_combo.keys.slice(0, potential_match.length).join("")) {
          return source_combo;
        }
      } else {
        if (_compare_arrays(potential_match, source_combo.keys)) {
          return source_combo;
        }
        if (allow_partial_match && _compare_arrays(potential_match, source_combo.keys.slice(0, potential_match.length))) {
          return source_combo;
        }
      }
    }
    return false;
  };

  _cmd_bug_check = function(combo_keys) {
    if (__indexOf.call(_keys_down, "cmd") >= 0 && __indexOf.call(combo_keys, "cmd") < 0) {
      return false;
    }
    return true;
  };

  _get_active_combo = function(key) {
    var keys_down, perfect_match, potentials, slice_up_array;
    keys_down = _keys_down.filter(function(down_key) {
      return down_key !== key;
    });
    keys_down.push(key);
    perfect_match = _match_combo_arrays(keys_down, _registered_combos);
    if (perfect_match && _cmd_bug_check(keys_down)) {
      return perfect_match;
    }
    potentials = [];
    slice_up_array = function(array) {
      var fuzzy_match, i, partial, _i, _ref;
      for (i = _i = 0, _ref = array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        partial = array.slice();
        partial.splice(i, 1);
        if (!partial.length) {
          continue;
        }
        fuzzy_match = _match_combo_arrays(partial, _registered_combos);
        if (fuzzy_match && __indexOf.call(potentials, fuzzy_match) < 0) {
          potentials.push(fuzzy_match);
        }
        slice_up_array(partial);
      }
    };
    slice_up_array(keys_down);
    if (!potentials.length) {
      return false;
    }
    if (potentials.length > 1) {
      potentials.sort(function(a, b) {
        return b.keys.length - a.keys.length;
      });
      if (potentials[0].length === potentials[1].length) {
        _log_error("Conflicting combos registered");
        return false;
      }
    }
    if (_cmd_bug_check(potentials[0].keys)) {
      return potentials[0];
    }
  };

  _get_potential_combo = function(key) {
    var combo, _i, _len;
    for (_i = 0, _len = _registered_combos.length; _i < _len; _i++) {
      combo = _registered_combos[_i];
      if (combo.is_sequence) {
        continue;
      }
      if (__indexOf.call(combo.keys, key) >= 0 && _cmd_bug_check(combo.keys)) {
        return combo;
      }
    }
    return false;
  };

  _add_to_active_combos = function(combo) {
    var active_key, active_keys, i, is_match, replaced, _i, _j, _len, _ref;
    replaced = false;
    if (__indexOf.call(_active_combos, combo) >= 0) {
      return false;
    } else if (_active_combos.length) {
      for (i = _i = 0, _ref = _active_combos.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        active_keys = _active_combos[i].keys.slice();
        for (_j = 0, _len = active_keys.length; _j < _len; _j++) {
          active_key = active_keys[_j];
          is_match = true;
          if (__indexOf.call(combo.keys, active_key) < 0) {
            is_match = false;
            break;
          }
        }
        if (is_match) {
          _active_combos.splice(i, 1, combo);
          replaced = true;
          break;
        }
      }
    }
    if (!replaced) {
      _active_combos.push(combo);
    }
    return true;
  };

  _remove_from_active_combos = function(combo) {
    var active_combo, i, _i, _ref;
    for (i = _i = 0, _ref = _active_combos.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      active_combo = _active_combos[i];
      if (active_combo === combo) {
        _active_combos.splice(i, 1);
        break;
      }
    }
  };

  _add_key_to_sequence = function(key) {
    var sequence_combo;
    _sequence.push(key);
    sequence_combo = _get_sequence(true);
    if (sequence_combo) {
      if (_sequence_timer) {
        clearTimeout(_sequence_timer);
      }
      _sequence_timer = setTimeout(function() {
        return _sequence = [];
      }, sequence_combo.wait || 500);
    } else {
      _sequence = [];
    }
  };

  _get_sequence = function(allow_partial) {
    var combo, i, match, _i, _j, _len, _ref;
    if (allow_partial == null) {
      allow_partial = false;
    }
    for (_i = 0, _len = _registered_combos.length; _i < _len; _i++) {
      combo = _registered_combos[_i];
      if (!combo.is_sequence) {
        continue;
      }
      if (!(combo.keys.length === _sequence.length || allow_partial)) {
        continue;
      }
      match = true;
      for (i = _j = 0, _ref = _sequence.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        if (combo.keys[i] !== _sequence[i]) {
          match = false;
          break;
        }
      }
      if (match) {
        return combo;
      }
    }
    return false;
  };

  _key_down = function(key, e) {
    var combo, potential_combo, sequence_combo;
    _add_key_to_sequence(key);
    sequence_combo = _get_sequence();
    if (sequence_combo) {
      _fire("keydown", sequence_combo);
    }
    combo = _get_active_combo(key);
    if (!combo) {
      potential_combo = _get_potential_combo(key);
    }
    if ((combo && !combo.allow_default) || (potential_combo && !potential_combo.allow_default)) {
      _prevent_default(e);
    }
    if (__indexOf.call(_keys_down, key) >= 0) {
      if (!_allow_key_repeat(combo)) {
        return false;
      }
    } else {
      _keys_down.push(key);
    }
    if (!combo) {
      return false;
    }
    _add_to_active_combos(combo, key);
    combo.keyup_fired = false;
    _fire("keydown", combo);
  };

  _key_up = function(key) {
    var active_combo, active_combos_length, combo, i, keys_remaining, sequence_combo, _i, _j, _k, _len, _len1, _ref;
    sequence_combo = _get_sequence();
    if (sequence_combo) {
      _fire("keyup", sequence_combo);
    }
    if (__indexOf.call(_keys_down, key) < 0) {
      return false;
    }
    for (i = _i = 0, _ref = _keys_down.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (key === _keys_down[i]) {
        _keys_down.splice(i, 1);
        break;
      }
    }
    for (_j = 0, _len = _active_combos.length; _j < _len; _j++) {
      active_combo = _active_combos[_j];
      if (__indexOf.call(active_combo.keys, key) >= 0) {
        combo = active_combo;
        break;
      }
    }
    if (!combo) {
      return;
    }
    keys_remaining = _keys_remain(combo);
    if (!combo.keyup_fired && (!combo.is_counting || (combo.is_counting && keys_remaining))) {
      _fire("keyup", combo);
      if (combo.is_counting) {
        combo.count += 1;
      }
    }
    active_combos_length = _active_combos.length;
    if (!keys_remaining) {
      if (combo.is_counting) {
        _fire("release", combo);
        combo.count = 0;
      }
      _remove_from_active_combos(combo);
    }
    if (active_combos_length > 1) {
      for (_k = 0, _len1 = _active_combos.length; _k < _len1; _k++) {
        active_combo = _active_combos[_k];
        if (combo === active_combo) {
          continue;
        }
        if (!_keys_remain(active_combo)) {
          _remove_from_active_combos(active_combo);
        }
      }
    }
  };

  _receive_input = function(e, is_keydown) {
    var key;
    if (_prevent_capture) {
      if (_keys_down.length) {
        _keys_down = [];
      }
      return;
    }
    if (!is_keydown && !_keys_down.length) {
      return;
    }
    key = _convert_key_to_readable(e.keyCode);
    if (!key) {
      return;
    }
    if (is_keydown) {
      return _key_down(key, e);
    } else {
      return _key_up(key);
    }
  };

  _validate_combo = function(combo) {
    var i, key, mod_key, non_modifier_keys, _i, _j, _k, _len, _len1, _ref, _ref1;
    for (i = _i = 0, _ref = combo.keys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      key = combo.keys[i];
      if (key === "meta" || key === "cmd") {
        combo.keys.splice(i, 1, _metakey);
        if (key === "cmd") {
          _log_error("Warning: use the \"meta\" key rather than \"cmd\" for Windows compatibility");
        }
      }
    }
    _ref1 = combo.keys;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      key = _ref1[_j];
      if (__indexOf.call(_valid_keys, key) < 0) {
        _log_error("Do not recognize the key \"" + key + "\"");
        return false;
      }
    }
    if (__indexOf.call(combo.keys, "meta") >= 0 || __indexOf.call(combo.keys, "cmd") >= 0) {
      non_modifier_keys = combo.keys.slice();
      for (_k = 0, _len1 = _modifier_keys.length; _k < _len1; _k++) {
        mod_key = _modifier_keys[_k];
        if ((i = non_modifier_keys.indexOf(mod_key)) > -1) {
          non_modifier_keys.splice(i, 1);
        }
      }
      if (non_modifier_keys.length > 1) {
        _log_error("META and CMD key combos cannot have more than 1 non-modifier keys", combo, non_modifier_keys);
        return true;
      }
    }
    return true;
  };

  _decide_meta_key = function() {
    if (navigator.userAgent.indexOf("Mac OS X") !== -1) {
      _metakey = "cmd";
    }
  };

  _bug_catcher = function(e) {
    var _ref;
    if (__indexOf.call(_keys_down, "cmd") >= 0 && ((_ref = _convert_key_to_readable(e.keyCode)) !== "cmd" && _ref !== "shift" && _ref !== "alt")) {
      return _receive_input(e, false);
    }
  };

  window.keypress = {};

  keypress.wire = function() {
    _decide_meta_key();
    document.body.onkeydown = function(e) {
      _receive_input(e, true);
      return _bug_catcher(e);
    };
    document.body.onkeyup = function(e) {
      return _receive_input(e, false);
    };
    return window.onblur = function() {
      var _valid_combos;
      _keys_down = [];
      return _valid_combos = [];
    };
  };

  keypress.sequence = function(string, callback) {
    var keys;
    keys = string.split(" ");
    return keypress.register_combo({
      keys: keys,
      on_keydown: callback,
      is_sequence: true
    });
  };

  keypress.combo = function(keys_array, callback) {
    return keypress.register_combo({
      keys: keys_array,
      on_keydown: callback
    });
  };

  keypress.register_many_combos = function(combo_array) {
    var combo, _i, _len;
    for (_i = 0, _len = combo_array.length; _i < _len; _i++) {
      combo = combo_array[_i];
      keypress.register_combo(combo);
    }
    return true;
  };

  keypress.register_combo = function(combo) {
    var property, value;
    for (property in _combo_defaults) {
      if (!__hasProp.call(_combo_defaults, property)) continue;
      value = _combo_defaults[property];
      console.log("working on extending", property, " : ", combo[property], value);
      if (combo[property] == null) {
        combo[property] = value;
      }
    }
    console.log("combo", combo);
    if (_validate_combo(combo)) {
      _registered_combos.push(combo);
      return true;
    }
  };

  keypress.listen = function() {
    return _prevent_capture = false;
  };

  keypress.stop_listening = function() {
    return _prevent_capture = true;
  };

  _convert_key_to_readable = function(k) {
    return _keycode_dictionary[k];
  };

  _keycode_dictionary = {
    8: "backspace",
    9: "tab",
    13: "enter",
    16: "shift",
    17: "ctrl",
    18: "alt",
    19: "pause",
    20: "caps",
    27: "escape",
    32: "space",
    33: "pageup",
    34: "pagedown",
    35: "end",
    36: "home",
    37: "left",
    38: "up",
    39: "right",
    40: "down",
    45: "insert",
    46: "delete",
    49: "1",
    50: "2",
    51: "3",
    52: "4",
    53: "5",
    54: "6",
    55: "7",
    56: "8",
    57: "9",
    65: "a",
    66: "b",
    67: "c",
    68: "d",
    69: "e",
    70: "f",
    71: "g",
    72: "h",
    73: "i",
    74: "j",
    75: "k",
    76: "l",
    77: "m",
    78: "n",
    79: "o",
    80: "p",
    81: "q",
    82: "r",
    83: "s",
    84: "t",
    85: "u",
    86: "v",
    87: "w",
    88: "x",
    89: "y",
    90: "z",
    91: "cmd",
    92: "cmd",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "\'",
    224: "cmd"
  };

  for (_ in _keycode_dictionary) {
    key = _keycode_dictionary[_];
    _valid_keys.push(key);
  }

}).call(this);
